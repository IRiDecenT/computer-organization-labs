# computer-organization-labs

verilog实现

Quartuns2 9.0版本太过古早难用，加上丑陋，代码体验极差

解决方案：vscode + Verilog插件（Digital IDE，WaveTrace） + iverilog（跨平台轻量级verilog仿真器）



课程大作业实现单周期CPU， 按照教材实现11条指令

R-type:

add rd rs rt

sub rd rs rt

subu rd rs rt

slt rd rs rt

sltu rd rs rt

I-type:

ori rt rs imm16

addiu rt rs imm16

lw rt rs imm16

sw rt rs imm16

beq rt rs imm16

J-type

j target



指令高6位为OP字段，每一个寄存器号字段为5位，目标地址25位，立即数16位，Rtype指令末6位为func字段

| 指令 | add    | sub    | subu   | slt    | sltu   | ori    | addiu  | lw     | sw     | beq    | jump   |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| OP   | 000000 | 000000 | 000000 | 000000 | 000000 | 001101 | 001001 | 100011 | 101011 | 000100 | 000010 |
| func | 100000 | 100010 | 100011 | 101010 | 101011 | x      | x      | x      | x      | x      | x      |

数据存储器模块为256个8位宽寄存器构成，每次读出32位的数据，一共可以存 256 / 4 = 64个32位宽的数据

指令存储器为512个8位宽的寄存器构成，每次读一个32位的指令，一共可以存512 / 4 = 128 条 指令 （可以通过调节开辟的数组大小调节） 

设计时指令存储器按照大端方式存放指令数据，数据存储器按照小端方式存放数据（指令用大端存放，把指令写到文件时比较方便）

第0，1，2，3寄存器被初始化为0，数据存储器全部初始化为1

对于PC，为了让每次取指令都落在一个规整的周期里，设计时对currentPC不赋初值（高阻抗），对nextPC赋为0



## 指令测试

| 指令  | 测试 |
| ----- | ---- |
| add   | ✅    |
| sub   | ✅    |
| subu  |      |
| slt   |      |
| sltu  |      |
| ori   |      |
| addiu |      |
| lw    | ✅    |
| sw    | ✅    |
| beq   |      |
| j     |      |

- 0号寄存器赋初值0，数据存储器中0号地址开始32位值赋初值为1，其余赋初值为0

  指令格式（指令二进制机器码和汇编表示对应寄存器编号位置有差异！）

- op rs rt rd shamt func

- op rs rt imm16

- op targert

# 手写汇编 + 手动汇编机器码 享大福！！！

lw 4(rt) 0(rs) 0(imm16) ：从0号地址取32位数放到4号寄存器	10001100000001000000000000000000	8C040000

lw 5(rt) 0(rs) 0(imm16) :  从0号地址取32位数放到5号寄存器	 10001100000001010000000000000000	8C050000

add 6(rd) 4(rs) 5(rt)： 把4号5号寄存器的值加起来存到6号寄存器	00000000100001010011000000100000	00853020

sw 6(rt) 0(rs) 4(imm16)： 把6号寄存器的值存到数据存储器的4号地址处 	10101100000001100000000000000100	AC060004

lw 7(rt) 0(rs) 4(imm16):  从4号地址取32位数放到7号寄存器	10001100000001110000000000000100 	8C070004  （证明sw确实把数据存到了数据存储器的四号地址处）

sub 8(rd) 4(rs) 7(rt)  测试带符号减法（1-2 = -1），（4号寄存器的值 - 7号寄存器的值） 存到8号寄存器	00000000100001110100000000100010	00874022

sw 8(rt) 0(rs) 8(imm16) 	10101100000010000000000000001000	AC080008 (通过busB证明sub指令计算的值确实存到了8号寄存器 通过看对应address的dataout证明sw确实把8号寄存器的值写到了指令存储器中)







## bugs：

1. 书p140、141中图上Rd和Rt选择错误
2. sw指令有bug，数据写不到数据存储器中    解决方案：对于reg和mem中读数据的触发条件改为always@(*)













