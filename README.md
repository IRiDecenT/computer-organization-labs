# computer-organization-labs

verilog实现

Quartuns2 9.0版本太过古早难用，加上丑陋，代码体验极差

解决方案：vscode + Verilog插件（Digital IDE，WaveTrace） + iverilog（跨平台轻量级verilog仿真器）



课程大作业实现单周期CPU， 按照教材实现11条指令

R-type:

add rd rs rt

sub rd rs rt

subu rd rs rt

slt rd rs rt

sltu rd rs rt

I-type:

ori rt rs imm16

addiu rt rs imm16

lw rt rs imm16

sw rt rs imm16

beq rt rs imm16

J-type

j target



指令高6位为OP字段，每一个寄存器号字段为5位，目标地址25位，立即数16位，Rtype指令末6位为func字段

| 指令 | add    | sub    | subu   | slt    | sltu   | ori    | addiu  | lw     | sw     | beq    | jump   |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| OP   | 000000 | 000000 | 000000 | 000000 | 000000 | 001101 | 001001 | 100011 | 101011 | 000100 | 000010 |
| func | 100000 | 100010 | 100011 | 101010 | 101011 | x      | x      | x      | x      | x      | x      |

数据存储器模块为256个8位宽寄存器构成，每次读出32位的数据，一共可以存 256 / 4 = 64个32位宽的数据

指令存储器为512个8位宽的寄存器构成，每次读一个32位的指令，一共可以存512 / 4 = 128 条 指令 （可以通过调节开辟的数组大小调节） 

设计时指令存储器按照大端方式存放指令数据，数据存储器按照小端方式存放数据（指令用大端存放，把指令写到文件时比较方便）

第0，1，2，3寄存器被初始化为0，数据存储器全部初始化为1

对于PC，为了让每次取指令都落在一个规整的周期里，设计时对currentPC不赋初值（高阻抗），对nextPC赋为0



## 指令测试

| 指令  | 测试 |
| ----- | ---- |
| add   | ✅    |
| sub   | ✅    |
| subu  | ✅    |
| slt   | ✅    |
| sltu  | ✅    |
| ori   | ✅    |
| addiu | ✅    |
| lw    | ✅    |
| sw    | ✅    |
| beq   | ✅    |
| j     |      |

- 0号寄存器赋初值0，数据存储器中0号地址开始32位值赋初值为1，其余赋初值为0

  指令格式（指令二进制机器码和汇编表示对应寄存器编号位置有差异！）

- op rs rt rd shamt func

- op rs rt imm16

- op targert

## 指令测试

0. lw 4(rt) 0(rs) 0(imm16) ：从0号地址取32位数放到4号寄存器	10001100000001000000000000000000	8C040000

1. lw 5(rt) 0(rs) 0(imm16) :  从0号地址取32位数放到5号寄存器	 10001100000001010000000000000000	8C050000

2. add 6(rd) 4(rs) 5(rt)： 把4号5号寄存器的值加起来存到6号寄存器	00000000100001010011000000100000	00853020

3. sw 6(rt) 0(rs) 4(imm16)： 把6号寄存器的值存到数据存储器的4号地址处 	10101100000001100000000000000100	AC060004

4. lw 7(rt) 0(rs) 4(imm16):  从4号地址取32位数放到7号寄存器	10001100000001110000000000000100 	8C070004  （证明sw确实把数据存到了数据存储器的四号地址处）

5. sub 8(rd) 4(rs) 7(rt)  测试带符号减法（1-2 = -1），（4号寄存器的值 - 7号寄存器的值） 存到8号寄存器	00000000100001110100000000100010	00874022        **即8号寄存器的值变为全f（-1）**

6. sw 8(rt) 0(rs) 8(imm16) 	10101100000010000000000000001000	AC080008 (通过busB证明sub指令计算的值确实存到了8号寄存器 通过看对应address的dataout证明sw确实把8号寄存器的值写到了指令存储器的8号地址处，**即8号地址处变为全f（-1）**)

7. addiu (1)rt (0)rs imm16(0000 1010 0000 0101)	 00100100000000010000101000000101 	24010A05 	1号寄存器末16位赋值为imm16（0A05）高12位置为0（符号扩展）

8. addiu (2)rt (0)rs imm16(1111 1111 1010 1000)	00100100000000101111111110101000	2402FFA8	2号寄存器末16位赋值imm16(FFA8) 高12位置全1 （符号扩展） 即2号寄存器值变为 FFFF FFA8

9. ori (1)rt (1)rs imm16(0000 0101 1001 0000)	00110100001000010000010110010000	34210590	ori对立即数是零扩展故该指令计算  	0000 0A05 ｜ 0000 0590 = （高16位0） 0000 1111 1001 0101 = 0000 0F95 即指令执行后1号寄存器值由 0000 0A05 变为 **0000 0F95**

10. ori 2(rt) 2(rs) imm16(1000 1111 0110 1100)  	00110100010000101000111101101100	34428F6C 	ori对立即数是零扩展该指令计算	FFFF FFA8 | 0000 8F6C = FFFF FFEC	即指令执行完后2号寄存器值由FFFF FFA8 变为**FFFF FFEC**

**通过上面的或获得的1号2号寄存器中的值就可以帮助我们测试slt与slu**

11. slt rs(1) rt(2) rd(3) shamt(五位0即可) func(101010)	00000000001000100001100000101010	0022182A	1号寄存器值（**0000 0F95**）与2号寄存器（**FFFF FFEC**）值进行**带符号整数**比较	显然前者为正后者为负	**故三号寄存器（rd）值设置为0**

12. sltu rs(1) rt(2) rd(3) shamt(全0) func(101011)	00000000001000100001100000101011	0022182B	1号寄存器值（**0000 0F95**）与2号寄存器（**FFFF FFEC**）值进行**无符号整数**比较	对于无符号显然前者小于后者	**故三号寄存器值（rd）设置为1(ALU设计的时候为设置为32位全1) 即3号寄存器变为ffff ffff**

**测试带符号和无符号减法（对于相同的值计算的结果都是一样的，区别就是判断溢出与否）**

- 对于带符号数减法指令测试，测试负最大值 - 1即 （1 + 31位0） - 1，由于此时没有负最大值，把负最大值直接写到数据存储器初值文件中，令12号地址处为负最大值（8000 0000）

13. lw rs(0) rt(4) imm16(12)	10001100000001000000000000001100	8C04000C	将12地址处的数据(8000 0000)写到4号寄存器中

14. sub rs(4) rt(5) rd(6) shamt(全0) func(100010)	00000000100001010011000000100010	00853022	4号寄存器（8000 0000） - 5号寄存器(0000 0001) 存到6号寄存器 	负最大值 - 1 = 正最大值 即6号寄存器的值变为7fff ffff，此时发生溢出（带符号减，观察overflow）**注意⚠️ 此时带符号减发生溢出，算出来的值7fff ffff并不会写到寄存器中，因为overflow取反变成0，屏蔽了RegWr=1信号**

- 对于无符号减法，测试 0 - 1， 由于无论是带符号数无符号数进行减法计算都是补码运算，所以计算的结果是0 + (-1) = -1（全f），但是对于无符号数，会把全f解读为无符号数的最大值，此时对于无符号数减数 > 被减数 发生溢出，但是由于无符号不判定溢出，所以overflow仍然为0

15. subu rs(0) rt(5) rd(6) shamt(全0) func(100011)	00000000000001010011000000100011	00053023	0号寄存器（0） - 5号寄存器（1）存到6号寄存器	6号寄存器变为ffff ffff



- 测试beq和j指令

上面指令执行完后，3号寄存器和6号寄存器中的 值相等均为ffffffff

16. beq rs(3) rt(6) imm16(2)	00010000011001100000000000000010	10660002	跳转到标黄的一行

插入几条指令来测试beq是否正确跳转

17. lw 10(rt) 0(rs) 0(imm16)	10001100000010100000000000000000	8C0A0000

18. lw 11(rt) 0(rs) 0(imm16)	10001100000010110000000000000000	8C0B0000

19. ==lw 12(rt) 0(rs) 0(imm16) 	10001100000011000000000000000000==	8C0C0000

20. lw 13(rt) 0(rs) 0(imm16) 	10001100000011010000000000000000	8C0D0000





## bugs：

1. 书p140、141中图上Rd和Rt选择错误

2. sw指令有bug，数据写不到数据存储器中    解决方案：对于reg和mem中读数据的触发条件改为always@(*)

3. **最头疼的一个BUG**：

   测试beq跳转时，发现在beq的时候会执行beq下条指令然后根据下条指令的下条指令再➕偏移量实现跳转，

   而且惊奇的发现明明branch和zero在3.3到3.5us的时候应该就要计算下地址，但是在下一个时钟周期居然进行了计算不可思议。

   ![截屏2023-12-21 15.17.13](/Users/yr/code/computer-organization/computer-organization-labs/imgs/截屏2023-12-21 15.17.13.png)

   通过单独调试取指令部件的PC和下地址逻辑发现，这个是一个verilog中部件的同步问题，虽然波形上偏移量、branch、zero信号显示的值是我们预期的，但是verilog代码中并不是立即更新，需要等待一段时间，才能正确更新，所以在计算下地址逻辑时需要#10等待一小段时间，这样我们进行下地址逻辑计算的时候，依据的信号才是我们预期的信号。

   ![截屏2023-12-21 15.26.12](/Users/yr/code/computer-organization/computer-organization-labs/imgs/截屏2023-12-21 15.26.12.png)

   

![截屏2023-12-21 15.27.25](/Users/yr/code/computer-organization/computer-organization-labs/imgs/截屏2023-12-21 15.27.25.png)





debug

[DEBUG] write 00000001 to reg04
[DEBUG] write 00000001 to reg05
[DEBUG] write 00000002 to reg06
[DEBUG] write 00000002 to memory address:00000004, 00000002
[DEBUG] write 00000002 to reg07
[DEBUG] write ffffffff to reg08
[DEBUG] write ffffffff to memory address:00000008, ffffffff
[DEBUG] write 00000a05 to reg01
[DEBUG] write ffffffa8 to reg02
[DEBUG] write 00000f95 to reg01
[DEBUG] write ffffffec to reg02
[DEBUG] write 00000000 to reg03
[DEBUG] write ffffffff to reg03
[DEBUG] write 80000000 to reg04
[DEBUG] write ffffffff to reg06













